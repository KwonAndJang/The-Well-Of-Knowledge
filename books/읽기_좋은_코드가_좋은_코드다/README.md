# 읽기 좋은 코드가 좋은 코드다 📓
## PART 0 서론
### 코드는 이해하기 쉬워야 한다
**가독성의 기본 정리 (The Fundamental Theorem of Readability)**
코드는 다른 사람이 그것을 이해하는 데 들이는 시간을 최소화 하는 방식으로 작성되어야 한다. 
즉, 상대방이 '이해' 를 위해 사용하는 시간이 최대한 적어야 한다는 의미.

**분량이 적으면 더 좋은가?**
일반적으로, 더 적은 분량의 코드로 같은 문제를 해결할 수 있다면 그것이 더 낫다.
하지만 분량이 적다고 해서 항상 좋은것은 아니다.


안좋은 예)

```jsx
return exponent >= 0 ? mantissa * (1 << exponent) : mantissa / ( 1 << -exponent);
```
좋은 예)
```jsx
if (exponent >= 0) {
    return mantissa * (1 << exponent);
} else {
    return mantissa / ( 1 << -exponent);
}
```

첫 번째 코드가 더 간결해보이지만, 두 번째 코드가 읽기에는 더 편하다.
다음의 한 줄짜리 코드를 이해하는 데 걸리는 시간은

```jsx
assert(!(bucket = findBucket(key)) || !bucket.isOccupied());
```

아래의 두 줄짜리 코드를 이해할 때보다 훨씬 더 많은 시간이 걸릴 수도 있다.

```jsx
bucket = findBucket(key);
if (bucket) assert(!bucket.isOccupied());
```

적은 분량으로 코드를 작성하는 것이 좋은 목표이긴 하지만, 이해를 위한 시간을 최소화하는 게 더 좋은 목표다.



## PART 1 표면적 수준에서의 개선
- 표면적 수준 : 좋은 이름, 좋은 설명, 코드를 보기 좋게 정렬 등..
### 이름에 정보를 담아내라
**특정한 단어 고르기**

```js
function getPage(url)
```
위에서의 `get` 은 별다른 의미를 전달하지 않는다. 로컬 캐시, 데이터베이스, 혹은 인터넷 중 어디에서 페이지를 가져오는것일까?

```js
function downloadPage(url) || function fetchPage(url)
```
만약 인터넷에서 가져온다면 위처럼 하는게 더 적절하지 않을까.

사용하는 모든 변수/함수에는 해당 값/행위를 묘사하는 적절한 단어가 들어가 있어야 보는 사람으로 하여금 이해가 더욱 쉽게 될 수 있다.


**보편적인 이름 피하기**

`tmp`, `retval`, `foo` 같은 이름 대신에 개체의 값이나 목적을 정확하게 설명하는 이름을 골라야 한다.

```jsx
const euclideanNorm = function(v) {
    let retval = 0.0;
    for (let i = 0; i < v.length; i += 1) {
        retval += v[i] * v[i];
    }
    return Math.sqrt(retval);
}
```

위 코드의 `retval`이라는 변수는 단순히 `반환되는 값`이라는 정보 외에는 아무 것도 담지 않는다.
더 좋은 이름은 변수의 목적이나 담고 있는 값을 설명해주어야 한다. 위의 예시에서 변수는 `v`를 제곱한 값을 모두 더하고 있으므로 `sumSquares`가 더 좋은 이름일 것이다.
이런 이름은 변수의 목적을 직접적으로 나타내어 추후 버그를 잡을 때도 도움이 된다.

```jsx
retval += v[i];
```

```jsx
sumSquares += v[i]; // 더해야 하는 "제곱"이 없다!
```
후자처럼 변수명이 `sumSquares`라면 버그를 더 명백하게 드러낸다.
다음 예시를 보자.

```jsx
if (right < left) {
    tmp = right;
    right = left;
    left = tmp;
}
```
이 경우에는 변수 목적 자체가 코드 몇 줄에서만 사용하는 임시저장소 역할로 제한되어 있으므로 `tmp`라는 이름이 좋다. `tmp`라는 이름은 코드를 읽는 사람에게 변수가 임시저장소 외에 다른 용도가 없다는 사실을 잘 전달한다. 

```jsx
let tmp = user.name;
tmp += " " + user.phoneNumber;
tmp += " " + user.email;
...
template.set("userInfo", tmp);
```
위의 변수도 짧게 존재하지만, 변수의 주된 목적이 임시적인 저장소로 국한되지 않으므로 이럴 때는 `userInfo`와 같은 이름이 더 적절하다.

> `tmp` 라는 이름은 대상이 짧게 임시적으로만 존재하고, 임시적 존재 자체가 변수의 가장 중요한 용도일 때에 한해서 사용해야 한다.


**추상적인 이름보다 구체적인 이름을 사용하기**
```jsx
function drawPolygonOfFourLines(a, b, c, d)

function drawRectangle(topLeft, bottomLeft, topRight, bottomRight)
```
한눈에 봐도 두 함수의 차이가 명확히 보인다.
변수나 함수 혹은 다른 요소에 이름을 붙일때는 추상적인 방식이 아니라 구체적인 방식을 사용해야 한다.

**추가적인 정보를 이름에 추가하기**
변수의 이름은 작은 설명문이다.
충분한 공간은 아니지만, 이름 안의 추가 정보는 변수가 눈에 보일때마다 전달되기 때문에 포함시키는게 도움된다.
- 단위를 포함하는 값들
    - 변수가 시간의 양이나 바이트의 수와 같은 측정치를 담고있다면, 변수명에 단위를 포함시키는게 도움된다.
        - 시간(sec, ms)
        - 크기(mb, kb)
        - 각도(degree, angle) 

- 중요한 속성 포함
    - 어떤 변수에 위험한 요소 혹은 인지해야하는 내용이 있다면 이러한 속성을 포함해야 한다.
        - ex) `password` -> `plainTextPassword`
        - ex) `comment` -> `unescapedComment`
        - ex) `data` -> `urlEncodedData`


**이름은 얼마나 길어야 하는가**

- 좁은 범위에서는 짧은 이름이 괜찮다.
    - 변수의 타입, 초기값 등 변수가 담고 있는 모든 정보가 한눈에 보이는 경우에는 짧은 이름을 사용해도 괜찮다.
    - 하지만 클래스의 멤버이거나 전역 변수라면(큰 범위를 가진다면), 이름에 의미를 분명하게 만들기 위한 정보를 포함해야 한다.

- 불필요한 단어 제거하기
    - 아무런 정보를 손실하지 않으면서 이름에 포함된 단어는 제거할 수 있다.
    - ex)
        - `convertToString()` -> `toString()`
        - `doServeLoop()` -> `serveLoop()`

**포맷팅으로 의미를 전달하라**
`_`이나 `-`, 대문자 등을 잘 이용하면 이름에 더 많은 정보를 담을 수 있다.

- ex)
    - `C++` 관습 - 클래스의 멤버 변수들은 `int offset_`처럼 `_`로 끝나야 한다.
    - `javascript` 관습 
        - `new`와 함께 호출되는 생성자 함수는 대문자로 시작(`pascal case`)하고, 다른 평범한 함수는 소문자로 시작(`camel case`)한다.
        - `jQuery` 라이브러리 함수 호출 시 `jQuery` 결과를 담는 변수 앞에 `$`를 붙인다.
        - `private` 변수는 `_offset`과 같이 `_`로 시작한다.

### 의미를 오해하기 쉬운 이름들 
> 본인이 지은 이름을 "다른 사람들이 다른 의미로 해석할 수 있을까?" 라는 질문을 던져보며 스스로 철저하게 확인해야 한다. 

**애매한 함수명**
```jsx
const results = Database.allObjects.customFilter(({year}) => year > 2011)
```
위 코드에서 results 는 어떤 데이터를 담고 있는지 알 수 없다.
- year > 2011 인 객체
- year < 2011 인 객체

대상을 고르는것인지, 혹은 제거하는것인지 불분명하기 때문에 문제가 생긴다.
즉, `customFilter` 의 의미가 모호하기 때문에 문제가 생기는 것이다.
이러한 이름은 의미를 오해할 가능성이 크므로 사용하지 않는것이 좋다.
만약 대상을 골라야 한다면 `select` 를 사용하고, 제거해야 한다면 `exclude` 를 사용하는것이 맞다.

**경계를 다룰때는 변수명에 유의해야한다**
```jsx
const CART_TOO_BIG_LIMIT = 10;

if (shoppingCart.Items.length > CART_TOO_BIG_LIMIT) {
    console.log("Too many items in cart")
}
```
위 코드를 봤을 때 `CART_TOO_BIG_LIMIT` 의 의미를 단번에 이해하기는 쉽지 않다. 
더 직관적인 의미로 `MAX_ITEMS_IN_CART` 를 사용한다면 코드는 간단하고 명확해진다.

```jsx
const start = 1;
const stop = 4;

console.log(integerRange(start, stop))
```
위의 경우에는 해당하는 수 까지 포함하는지, 아니면 포함하지 않는지가 명확하지 않다.
따라서, `start`, `stop` 대신 `first`, `last` 를 사용하면 범위를 포함한다는 의미가 더욱 명확해진다.



**boolean 변수에 이름 붙이기**
boolean 변수 혹은 boolean 값을 반환하는 함수에 이름을 붙일 때는 `ture`와 `false`가 각각 무엇을 의미하는지 명확해야 한다.

```jsx
let readPassword = true
```
위 코드는 읽는 방법에 따라 두 가지 상반된 해석이 가능하다.
- 우리는 패스워드를 읽을 필요가 있다.
- 패스워드가 이미 읽혔다.

이 경우에는 `read`라는 단어를 사용하지 않는 것이 최선이다. 대신 `needPassword` 혹은 `authenticated`를 사용하는 것이 나을 것이다.

`is`, `has`, `can`, `should`와 같은 단어를 더하면 boolean 값의 의미가 더 명확해진다.

또한, 이름에서는 의미를 부정하는 용어는 피하는 것이 좋다.
```jsx
let disableSSL = false;
```
위와 같은 이름 대신 아래와 같은 이름이 더 좋다.
```jsx
let useSSL = true;
```


**사용자의 기대에 부응하기**
사용자가 어떤 이름의 의미를 특정한 방식으로 이해해서 실제로 다른 의미가 있음에도 오해하는 경우가 있다.

**ex) `getXxx()`**
대게 get으로 시작되는 이름의 메서드는 '가벼운 접근자'로서 단순히 내부 멤버 변수를 반환한다고 관행적으로 생각한다. 
만약 `getMean()`이라는 특정 배열의 원소를 모두 순회하여 평균을 구하는 메서드가 있다고 해보자. 거기에 데이터가 많다면 이 메서드는 많은 시간을 소요할 것이다. 이를 모르는 사용자가 이 메서드의 연산이 간단할 것이라고 생각하고 부주의하게 `getMean()`을 호출할지도 모른다.
이러한 경우에는 메서드명을 `computeMean()`과 같이 시간이 소요되는 연산이라는 사실을 명확하게 드러내는 것이 좋다.


### 미학

좋은 소스코드는 '눈을 편하게'해야한다. 빈칸, 정렬, 코드의 순서 등을 통해 읽기 편한 코드를 작성하는 방법을 알아보자.

- 코드를 읽는 사람이 이미 친숙한, 일관성 있는 레이아웃을 사용하라
- 비슷한 코드는 서로 비슷해 보이게 만들어라
- 서로 연관된 코드는 하나의 블록으로 묶어라


**일관성과 간결성을 위해 줄 바꿈을 재정렬하기**
- 비슷한 코드는 비슷하게 보여야 한다.
- 여러 블록에 담긴 코드가 모두 비슷한 일을 수행하면, 실루엣이 동일해 보이게 만들어라

**선언문을 블록으로 구성하기**
- 빈 줄을 이용하여 커다란 블록을 논리적인 문단으로 나누자
**코드를 "문단"으로 나누기**
- 비슷한 생각을 하나로 묶어서, 성격이 다른 생각과 구분하기
- 문단은 "시각적 디딤돌" 역할을 수행한다. 문단이 없으면 하나의 페이지 안에서 읽던 부분을 놓치기 쉽다.
- 하나의 문단에서 다른 문단으로의 전진을 촉진시킨다

사실 js에서는 eslint나 prettier를 사용하여 간편하게 코드의 일관성을 유지할 수 있다.

### 주석
- 주석의 목적은 코드를 읽는 사람이 코드를 작성한 사람만큼 코드를 잘 이해하게 돕는 데 있다.

**코드에서 빠르게 유추할 수 있는 내용은 주석으로 달지 말라**
- 나쁜 이름에 주석을 달지 마라 - 대신 이름을 고쳐라

나쁜 이름이 대한 변명을 주석이 할 이유는 없다. 코드가 가진 나쁜 가독성을 메우려고 노력하는 '애쓰는 주석'을 달지 말자. 이름 자체가 정확한 설명을 하도록 코드를 작성하는 것이 낫다.

> 좋은 코드 > 나쁜 코드 + 좋은 주석

**생각을 기록하라**
- `TODO:` 아직 하지 않은 일
- `FIXME:` 오동작을 일으킨다고 알려진 코드
- `HACK:` 아름답지 않은 해결책

위와 같이 팀 내 약속에 따라 주석의 포맷을 맞추어 사용하는 것도 좋다.

**상수에 대한 설명**
상수를 정의할 때 그 상수가 무엇을 의미하는지, 그것이 왜 특정한 값을 갖게 되었는지 '사연'이 존재할 것이다. 

```jsx
const NUM_THREADS = 8;
```
별도의 설명이 필요하지 않아 보이지만, 이런 상수값을 선택한 사람은 분명히 더 많은 사실을 알고 있을 것이다.

```jsx
// 이 상수 값이 2 * NUM_PROCESSORS 보다 크거나 같으면 된다.
const NUM_THREADS = 8;
```
이제 코드를 읽는 사람은 상수값을 어떻게 변경해야 하는지 알게 되었다.

또한 상수의 특정한 값이 아무런 의미를 갖지 않는 경우도 있는데, 이러한 사실을 알려주는 주석도 유용하다.


**글 쓰는 두려움을 떨쳐내라**
실제로 많은 개발자들은 주석 달기를 달가워하지 않는다. 좋은 주석을 창작하기 위해서 시간을 들이는 것을 아깝게 생각하기 때문이다.
이와 같은 "글 쓰는 두려움"을 해결하기 위해서는 일단 그냥 쓰기 시작하는게 해결책이 될 수 있다. 다듬어지지 않은 생각이더라도 일단 쓰기 시작하라.

- 마음에 떠오르는 생각을 무조건 적어본다.
- 주석을 읽고 무엇이 개선되어야 하는지 확인한다.
    - 주의를 기울여야 하는 내용
    - 불필요한 내용
    - 애매모호한 내용
- 개선한다.

### 명확하고 간결한 주석 달기
> 작은 공간에 최대한 많은 정보를 담는 방법에 대해서 생각해보자.

**주석을 간결하게 하기**
```
// 총 3개의 인자를 받는다
// begin 은 시작 값이다.
// end 는 마지막 값이다.
// target 은 찾고자 하는 값이다.
// begin과 end 사이의 target 값을 찾는다. 
function binarySearch(begin, end, target)
```

```
// begin 과 end 사이에 존재하는 target 값을 찾아서 반환한다
function binarySearch(begin, end, target)
```

주석이 많이 필요한 경우가 아니라면 최대한 간결하게 작성한다.

**모호한 대명사는 피하기**
```jsx
// 데이터를 캐시에 넣어라. 하지만 그전에 그것이 너무 큰지 먼저 확인하라
```
위에서의 그것이 데이터를 지칭하는지, 아니면 캐시를 지칭하는지 알 수 없다.
여기서 `그것` 을 파악하기 위해 시간을 들여야 한다면 과연 주석을 작성한 의미가 있을까?

```jsx
// 데이터를 캐시에 넣어라. 하지만 그전에 데이터가 너무 큰지 먼저 확인하라

// 데이터가 충분히 작으면, 데이터를 캐시에 넣어라
```
이렇게 한다면 혼동의 가능성을 없애고, 보는 사람으로 하여금 이해에 필요한 시간을 허비하지 않도록 할 수 있다.


**엉터리 문장을 다듬어라**
```jsx
// 이 URL을 전에 이미 방문했는지에 따라 다른 우선순위를 부여한다.
```
이 문장은 어느 정도 괜찮지만, 다음 문장과 비교해보자.
```jsx
// 전에 방문하지 않은 URL에 높은 우선순위를 부여하라.
```
아래 문장이 더 간단하고, 짧고, 직접적이다. 또한 아직 방문하지 않은 URL에 높은 우선순위가 부여된다는 사실까지 설명하고 있다. 앞의 문장은 이러한 정보를 담아내지 못한다.


**함수의 동작을 명확하게 설명해라**
파일에 담긴 줄 수를 세는 함수를 다음과 같이 작성했다고 해보자.
```jsx
// 이 파일에 담긴 줄 수를 반환한다.
const countLines = function(filename) { ... }
```
위의 주석은 그다지 명확하지 않다. '줄'을 정의하는 방법이 여러 가지이기 때문이다.
- `""`(빈 파일)은 줄 수가 0인가 1인가?
- `"hello"`는 줄 수가 0인가 1인가?
- `"hello\n"`는 줄 수가 1인가 2인가?
- `"hello\n world"`는 줄 수가 1인가 2인가?
- `"hello\n\r cruel\n world\r"`는 줄 수가 2, 3, 4 중 어느 것인가?

```jsx
// 파일 안에 새 줄을 나타내는 바이트('\n')가 몇 개 있는지 센다.
const countLines = function(filename) { ... }
```
이 주석은 이전 주석에 비해 그리 길어지지 않았지만 훨씬 더 많은 정보를 담는다. 코드를 읽는 사람에게 개행문자가 없으면 0이 반환될 거라는 사실을 알려주며 `\r`(`Carriage Return`)은 무시될 거라는 사실도 알려준다.

**코너케이스를 설명해주는 입/출력 예를 사용하라**
주석을 작성하는 데 신중하게 선택된 입/출력 예는 천 마디 말보다 위력적이다.
```jsx
// 입력된 src 의 chars 라는 접두사와 접미사를 제거한다.
const strip = function(src, chars) { ... }
```
- `chars`가 제거되어야 하는 `정확한 부분 문자열`을 의미하는가 아니면 `특정한 순서가 정해지지 않은 문자 집합`을 의미하는가?
- `src`의 끝에 `chars`가 여러 번 있으면 어떻게 되는가?

이러한 의문에 대해 잘 선택된 입출력 예는 대답을 제공한다.

```jsx
// ...
// ex) strip("abba/a/ba", "ab")은 "/a/"를 반환
const strip = function(src, chars) { ... }
```
이 예는 `strip()`의 기능 전체를 보여주어 위의 의문에 답이 된다.



**코드의 의도를 명시하기**
주석 달기는 코드를 작성하면서 생각했던 바를 나중에 코드를 읽는 사람에게 전달하는 의미를 지닌다.
하지만 대부분의 주석은 새로운 정보 없이 그냥 코드가 수행하는 동작을 문자로 설명하는 데 그친다

**이름을 가진 함수 파라미터 주석**
**정보 축약형 단어를 사용하라**
```jsx
// 주소값에서 불필요한 빈 칸을 제거한다. 그리고 `Avenue` 를 `Ave`로 바꾸는 것과 같은
// 정리 작업을 수행한다. 이러한 과정으로 사실상 같지만 다르게 입력된
// 주소는 동일한 방식으로 정리된 값을 갖게 되어 동일한 주소를 가지는지를
// 값들을 서로 비교해서 확인할 수 있다.
```

이러한 주석은 더욱 간결하게 정리될 수 있다.

```jsx
// 주소값을 표준화한다. (불필요한 빈칸을 제거하고, `Avenue` -> `Ave` 등의 정리 작업을 수행한다.)
```

경험적인, 주먹구구식, 순진한 해법 과 같이 다양한 의미를 함축하는 단어나 표현이 많다. 길게 늘어지는 주석을 써야 하는 상황이라면 프로그래밍의 전형적인 상황을 묘사하는 표현이 있는지 확인하는 편이 좋다. 

## PART 2 루프와 논리를 단순화하기 

### 읽기 쉽게 흐름제어 만들기
흐름을 제어하는 조건과 루프 그리고 여타 요소를 최대한 '자연스럽게'만들도록 노력하라. 코드를 읽다가 다시 되돌아가서 코드를 읽지 않아도 되게끔 만들어야 한다.

**조건문에서 인수의 순서**
다음 두 코드에서 어떤 코드가 더 읽기 쉬운지 생각해보자.
```jsx
if (length >= 10) { ... }
```


```jsx
if (10 <= length) { ... }
```

대부분은 첫 번째 코드가 더 읽기 쉽다고 느낄 것이다. 다음 코드도 보자.

```jsx
while(receivedBytes < expectedBytes) { ... }
```

```jsx
while(expectedBytes > receivedBytes) { ... }
```

이 경우에도 첫 번째 코드가 더 읽기 편하다. 이와 관련한 규칙은 다음과 같다.

|             왼쪽            |              오른쪽              |
|:-------------------------:|:-------------------------------------:|
| 값이 더 유동적인 '질문을 받는' 표현 | 더 고정적인 값으로, 비교 대상으로 사용되는 표현 |

**`if/else` 블록의 순서**

`if/else`문은 아래와 같이 블록의 순서를 자유롭게 바꿔서 작성할 수 있다.

```jsx
if (a === b) {
    // 첫 번째 경우   
} else {
    // 두 번째 경우
}
```

```jsx
if (a !== b) {
    // 두 번째 경우   
} else {
    // 첫 번째 경우
}
```
이러한 경우에 대해 다음과 같은 규칙을 적용해보자.

- 부정이 아닌 긍정을 다루자. 즉, `if(!debug)`가 아니라 `if(debug)`를 선호하자.
- 간단한 것을 먼저 처리하자. 이렇게 하면 동시에 같은 화면에 `if/else` 구문을 나타낼 수도 있다.
- 더 흥미롭고, 확실한 것을 먼저 다룬다.

이런 규칙들이 서로 충돌을 일으키는 경우도 있지만 더 중요한 것을 파악하면 된다.

다음은 부정해야 더 단순하고 흥미로우면서 동시에 위험해지는 경우다.

```jsx
if (!file) {
    // error
} else {
    // ...
}
```
이러한 사항에 주의를 기울이고 자신이 작성하는 `if/else` 문이 이상한 순서로 작성되었는지 확인하자.

**삼항 연산자 (`condition ? a : b`)를 이용하는 조건문 표현**
삼항 연산자를 사용한 표현이 가독성에 미치는 영향은 논쟁의 대상이다. 
여러 줄에 걸쳐서 나타날 표현을 한 줄에 담아 좋은 방법으로 보기도 하고, 반대로 이런 표현이 오히려 읽기 혼란스럽고 디버깅이 어렵다고 보기도 한다.

다음은 삼항 연산자가 읽기 편하고 간결한 경우다.
```jsx
timeStr += (hour >= 12) ? "pm" : "am";
```
삼항 연산자를 사용하지 않으면 다음과 같이 작성해야 한다.

```jsx
if (hour >= 12) {
    timeStr += "pm";   
} else {
    timeStr += "am";
}
```

하지만 이런 표현은 쉽게 복잡해지기도 한다.

```jsx
return exponent >= 0 ? mantissa * (1 << exponent) : mantissa / ( 1 << -exponent);
```
이러한 코드는 `if/else` 문으로 작성하는 편이 더 자연스럽다.

```jsx
if (exponent >= 0) {
    return mantissa * (1 << exponent);
} else {
    return mantissa / ( 1 << -exponent);
}
```

- 줄 수를 최소화하는 일보다 다른 사람이 코드를 읽고 이해하는 데 걸리는 시간을 최소화하는 일이 더 중요하다.
- 기본적으로 `if/else`를 사용하고, 삼항 연산자는 매우 간단할 때 사용하는 것이 좋다.

**`do/while` 루프를 피하라**

`do/while` 루프는 코드 블록이 아래에 있는 조건에 따라서 다시 실행될 수 있다. 일반적으로 논리적 조건은 그것이 감싸는 코드 위에 놓인다. `if`, `while`, `for`문의 동작은 이와 같이 위에서 아래로 읽는데, 그 역순인 `do/while`문은 코드를 두 번 읽게 되기 때문에 부자연스럽다.
다행히도 대부분의 `do/while`루프는 `while`로 대체될 수 있다. 

**중첩을 최소화하기**
코드의 중첩이 심할수록 이해하기 어렵다. 

```jsx
if (userResult === SUCCESS) {
    if (permissionResult !== SUCCESS) {
        reply.writeErrors("error ")
        reply.done();
        return;
    } 
    reply.writeErrors("");
} else {
    reply.writeErrors(userResult);
}
reply.done();
```
이런 코드는 좋지 못한데, 코드를 읽는 사람이 SUCCESS인 경우와 SUCCESS가 아닌 경우를 계속해서 왔다 갔다 하기 때문이다. 

위 코드가 어떻게 생성된 것인지 알아보자.

```jsx
if (userResult === SUCCESS) {
    reply.writeErrors("");
} else {
    reply.writeErrors(userResult);
}
reply.done();
```
원래 코드는 이렇게 간단했다. 하지만 어떤 개발자가 두 번째 동작(주석 처리된 부분)을 집어넣었다.

```jsx
if (userResult === SUCCESS) {
    // if (permissionResult !== SUCCESS) {
    //     reply.writeErrors("error ")
    //     reply.done();
    //     return;
    } 
    reply.writeErrors("");
else { ...
```
이런 수정은 일리가 있지만, 당사자가 아닌 다른 사람이 나중에 이 코드를 읽으면 당사자가 코드를 추가하며 생각했던 문맥은 모두 사라진다. 

> 코드를 수정해야 하는 상황이라면 나의 코드를 새로운 관점에서 바라보자. 뒤로 한걸음 물러서서 코드 전체를 보자.

이제 이 코드를 개선해보자. 이렇게 특정한 조건을 만나면 함수를 반환하기 위해서 삽입된 중첩은 '실패한 경우들'을 최대한 빠르게 처리하고 함수에서 반환하여 제거할 수 있다.

```jsx
if (userResult !== SUCCESS) {
    reply.writeErrors(userResult);
    reply.done();
    return;
}

if (permissionResult !== SUCCESS) {
    reply.writeErrors("error ")
    reply.done();
    return;
} 

reply.writeErrors("");
reply.done();
```
이 코드는 이제 두 단계가 아닌 한 단계 중첩을 가진다. 모든 `if` 블록은 `return`과 함께 끝나므로 코드를 편하게 읽을 수 있다.

이렇게 중간에 반환하는 방식은 루프에서도 적용할 수 있다.


### 거대한 표현을 잘게 쪼개기
**설명 변수**
커다란 표현을 쪼개는 가장 슁누 방법은 작은 하위표현을 담을 `추가 변수` 를 만드는 것이다. 추가 변수는 하위표현의 의미를 설명하므로 `설명 변수` 라고도 한다.

```jsx
if (line.split(":")[0].strip() === "root")
```

```jsx
const userName = line.split(":")[0].strip();

if (userName === "root")
```

같은 코드이지만 하위변수를 만들면서 가독성이 올라간다. 


**요약 변수**
의미를 쉽게 파악할 수 있어 별도의 설명을 요구하지 않는 표현이라고 해도, 새로운 변수로 담아두는 방법은 여전히 유용할 수 있다.
커다란 코드의 덩어리를 짧은 이름으로 대체하여 더 쉽게 관리하고 파악하는 목적을 가진 변수를 요약 변수라고 한다.


```jsx
if (request.userId === document.ownerId) {
    // 사용자가 문서 수정 가능
}
...
if (request.userId !== document.ownerId) {
    // 사용자는 문서 수정 불가능
}
```

위와 같은 코드에서 `request.userId === document.ownerId` 를 변수에 할당한다면 가독성이 더욱 좋아진다. 

```jsx
const userOwnsDocument = request.userId === document.ownerId;

if (userOwnsDocument) {
    // 사용자가 문서 수정 가능
}
...
if (!userOwnsDocument) {
    // 사용자는 문서 수정 불가능
}
```

요약변수를 사용함으로써 위와 같은 이점을 얻을 수 있다

**드모르간의 법칙 사용하기**
```jsx
1) not(a or b or c) => (not a) and (not b) and (not c)
2) not(a and b and c) => (not a) or (not b) or (not c)
```

위 같은 방법으로 불리언 표현을 간단하게 만들 수 있다.

```jsx
if (!(file && !protected)) {
    console.log("파일을 읽을 수 없다.")
}
```

```jsx
if (!file || protected)) {
    console.log("파일을 읽을 수 없다.")
}
```

같은 내용의 코드이지만 밑의 코드가 괄호가 더 적고 가독성이 높다.

**쇼트 서킷 논리 오용하지 말기**
대부분의 프로그래밍 언어에서 불리언 연산은 쇼트 서킷 평가를 수행한다. 
`if(a || b)` 에서 a가 참이면 b는 평가하지 않는다.
매우 편리하지만 때로는 복잡한 연산을 수행할 때 오용될 수도 있다.

`assert((!(bucket = FindBucket(key))) || !bucket.isOccupied())`

위 코드는 "이 키를 위한 바구니를 구하고, 바구니가 null이 아니면 그것을 다른 누군가 차지하고 있지 않은지 확인해라"이다.

한 줄짜리 코드이지만, 의미를 이해하기 위해서 생각을 이해하기 위해 시간을 들여야 한다.
만약 위 코드를 아래처럼 바꾼다면 단번에 이해할 수 있다.

```jsx
const bucket = FindBucket(key);

if (bucket !== null) {
    assert(!bucket.isOcupied)
}
```

코드를 작성할 때 너무 `영리하게` 작성하지 않아야 한다.
작성자의 의도와 다르게 이후 이 코드를 보는 사람으로 하여금 혼란을 야기할 수 있기 때문이다. 

**거대한 구문 나누기**
```jsx
const updateHighlight = (messageNum) => {
    if ($("#vote_value" + messageNum).html() === "up") {
        $("thumbs_up" + messageNum).addClass("hilighted");
        $("thumbs_down" + messageNum).removeClass("hilighted");
    } else if ($("#vote_value" + messageNum).html() === "down") {
        $("thumbs_up" + messageNum).removeClass("hilighted");
        $("thumbs_down" + messageNum).addClass("hilighted");
    } else {
        $("thumbs_up" + messageNum).removeClass("hilighted");
        $("thumbs_down" + messageNum).removeClass("hilighted");
    }
}
```

```jsx
const updateHighlight = (messageNum) => {
    const HIGHLIGHTED = "hilighted";
    const thumbsUp = $("thumbs_up" + messageNum);
    const thumbsDown = $("thumbs_down" + messageNum);
    const voteValue = $("#vote_value" + messageNum).html();

    if (voteValue === "up") {
        thumbsUp.addClass(HIGHLIGHTED);
        thumbsDown.removeClass(HIGHLIGHTED);
    } else if (voteValue "down") {
        thumbsUp.removeClass(HIGHLIGHTED);
        thumbsDown.addClass(HIGHLIGHTED);
    } else {
        thumbsUp.removeClass(HIGHLIGHTED);
        thumbsDown.removeClass(HIGHLIGHTED);
    }
}
```

코드를 한눈에 살펴보기 용이하도록 위와같이 구문을 나눈다면 읽는 사람의 머리를 강타하는 거대한 구문이 탄생하지 않을 수 있다.

### 변수와 가독성

변수를 잘못 사용하면 아래와 같은 문제들이 발생할 수 있다.

1. 변수의 수가 많을수록 기억하고 다루기 더 어려워진다.
2. 변수의 범위가 넓어질수록 기억하고 다루는 시간이 더 짧아진다.
3. 변수값이 자주 바뀔수록 현재값을 기억하고 다루기가 더 어려워진다.

**변수 제거하기**

불필요한 임시 변수들은 아래와 같다.
- 복잡한 표현을 잘게 나누지 않는다.
- 명확성에 도움이 되지 않는다. (그 자체로 이미 명확한 경우)
- 한 번만 사용되어 중복된 코드를 압축하지 않는다.
- 단순히 중간 결과만 저장하는 변수 -> 가능하다면 결과를 얻자마자 반환하고 불필요한 변수는 제거하는 것이 좋다.

**변수의 범위를 좁혀라**
"전역 변수를 피하라"는 조언은 한번쯤 들었을 것이다. 전역 변수는 어디에서 어떻게 사용되는지 일일이 확인하기 어렵고, 전역 변수의 이름과 지역 변수의 이름이 중복되어 namespace가 더러워질 수 있다. 또한 어떤 코드가 지역 변수를 변경할 때 실수로 전역 변수를 변경하거나 그 반대의 경우가 발생할 수 있다.
전역 변수뿐만 아니라 모든 변수의 '범위를 좁히는 일'은 언제나 좋다.

변수에 더 제한적인 접근을 이용하면 코드를 읽는 사람이 한꺼번에 생각해야 하는 변수 수를 줄여줄 수 있다.

클래스의 멤버 변수는 어떤 의미에서 해당 클래스 내에 존재하는 미니 전역 변수라고 볼 수 있는데, 커다란 클래스는 모든 멤버 변수를 일일이 기억하거나 어느 메서드가 값을 변경하는지 알기 어려우므로 이러한 미니 전역 변수도 적을수록 더 좋다.

- 메서드를 정적 static으로 만들어 클래스 멤버 접근을 제한하라
    - 가급적 정적 메서드는 코드를 읽는 사람에게 '이 코드는 저 변수들로부터 독립적'이라는 사실을 알려주는 좋은 방법이다.
- 커다란 클래스를 여러 작은 클래스로 나누는 방법
    - 작은 클래스들이 서로 독립적일 때 유용하다.
    - 만약 클래스를 두 개의 작은 클래스로 나누었는데 서로의 멤버를 참조한다면 의미가 없어진다.
- 자바스크립트에서 private 변수 만들기
```jsx
let submitted = false; // 전역 변수

const submitForm = function(fromName) {
    if (submitted) {
        return; // form을 두 번 제출하지 않는다.
    }
    ...
    submitted = true;
}
```

`submitted`와 같은 전역 변수는 `submitForm`에서만 사용되는 것처럼 보이지만 확실히 알 수 없다. 이런 상황은 클로저를 활용하여 해결할 수 있다.

```jsx
const submitForm = (function() {
    let submitted = false;
    
    return function(fromName) {
        if (submitted) {
            reutrn;
        }
    }
    ...
    submitted = true;
})();
```
- 정의를 아래로 옮기기
    - 많은 변수를 가지고 있는 긴 함수인 경우 지금 당장 사용되지 않는 변수조차 일단 염두에 두게 강제하는 것은 좋지 않다.
    - 각각의 정의는 실제로 사용하기 바로 직전 위치에 선언하는 것이 좋다.

**값을 한 번만 할당하는 변수를 선호하라**
변수들의 값이 변한다면 변수의 값을 일일이 기억해야 하므로 프로그램을 따라가는 일은 어려워진다. 반면, 값이 '영원히 고정된' 상수는 생각하기 편하다.
변수 값의 변화가 꼭 필요하지 않다면 각 언어의 `const`, `final` 등을 사용하여 상수로 선언하는 것이 좋다.

## PART 3 코드 재작성하기

### 상관없는 하위문제 추출하기
엔지니어링은 커다란 문제를 작은 문제들로 쪼갠 다음, 각각의 문제에 대한 해결책을 구하고, 다시 하나의 해결책으로 맞추는 일련의 작업을 한다.
큰 흐름과 관계가 적은 하위 문제를 적극적으로 발견하여 추출해야 한다.

1. 주어진 함수나 코드 블록을 보고, 상위 수준에서 본 이 코드의 목적이 무엇인지 파악한다.
2. 코드의 모든 줄에 대해 이 코드는 `직접적으로 목적을 위해서 존재`하는지, 혹은 `목적을 위해서 필요하긴 하지만 목적 자체와 직접적으로 상관없는 하위 문제를 해결`하는지 확인한다.
3. 원래의 목적과 직접적으로 관련되지 않은 하위문제를 해결하는 코드 분량이 많으면, 이를 추출해서 별도의 함수로 만든다.

**순수한 유틸리티 코드**
어떠한 라이브러리에 추가적으로 필요하다고 느끼는 함수가 있다면 직접 구현하여 다른 프로젝트에서도 사용할 수 있는 유틸리티 코드 모음을 만들자.

**일반적인 목적의 코드**

예를 들어, 아래와 같은 ajax 통신 코드가 있고 중간에 디버깅을 위해 응답 데이터를 alert으로 노출한다고 가정해 보자.(보통 이렇게 하지는 않겠지만..)

```jsx
ajaxPost({
    url: "http://example.com/submit",
    data,
    onSuccess: function(responseData) {
        let str = "{\n";
        for (const key in responseData) {
            str += ` ${key} = ${obj[key]}\n`;
        }
        alert(str + "}");
        
        // ...
    } 
});
```
이 코드의 상위수준 목적은 서버에 ajax 호출을 하고 응답을 처리하는 것이다. 하지만 코드의 대부분이 이런 목적과는 관계없는 하위 문제, 즉 객체에 담긴 내용을 예쁘게 출려갛는 일을 한다. 이러한 코드를 추출하여 `formatPretty`함수로 만들어보자.

```jsx
const formatPretty = function(obj) {
    let str = "{\n";
    for (const key in obj) {
        str += ` ${key} = ${obj[key]}\n`;
    }
    return str + "}";
}
```
`formatPretty`를 추출하면 장점이 많다. 우선 함수를 호출하는 코드를 간단하게 하고, 다른 곳에서도 `formatPretty`를 간편하게 사용할 수 있다. 또한 `formatPretty`함수를 훨씬 쉽게 개선할 수 있는데 별도로 분리된 함수를 다룰 때는 기능을 더하고, 가독성을 개선하는 일이 상대적으로 쉽게 느껴진다.

이제는 아래와 같이 쉽게 개선할 수 있다.

```jsx
const formatPretty = function(obj, indent = "") {
    // null or 객체가 아닌 경우 처리
    if (obj === null) return "null";
    if (obj === undefined) return "undefined";
    if (typeof obj === "string") return `"${obj}"`;
    if (typeof obj !== "object") return String(obj);
    
    // null이 아닌 객체 처리
    let str = "{\n";
    for (const key in obj) {
        str += ` ${key} = ${formatPretty(obj[key], indent)}\n`;
    }
    return str + "}";
}
```

**기존의 인터페이스를 단순화하기**
라이브러리가 깔끔한 인터페이스를 제공하면 누구나 좋아한다. 적은 수의 인수를 받고, 별다를 설정을 요구하지 않으며, 사용하기 간편한 인터페이스가 좋다.
만약 자신이 사용하는 인터페이스가 깔끔하지 않다면, 깔끔한 wrapper로 보완할 수 있다.

**필요에 맞춰 인터페이스의 형태를 바꾸기**
프로그램 안에 있는 많은 코드는 다른 코드를 지원하기 위해 존재한다. 예를 들면 함수에 주어지는 입력을 설정하거나 출력된 결과를 처리하는 일 등을 수행한다. 이런 glue 코드는 프로그램의 실제 논리와 직접적인 연관이 없는데, 이 경우 따로 코드를 분리하여 독자적인 함수를 만드는 것이 좋다.

### 한 번에 하나씩

한 번에 여러 가지 일을 수행하는 코드는 이해하기 어렵다. 즉, 한 번에 하나의 작업만 수행하게 코드를 구성해야 한다.

**작업은 작을 수 있다**
블로그 사용자가 댓글에 '추천', '반대'의 의사표시를 할 수 있는 기능이 있다고 하자. 댓글의 총점은 모든 득표의 합으로 계산된다. '추천'은 +1점이고, '반대'는 -1점이다.
사용자가 추천을 하거나 이미 선택한 추천을 변경하려고 버튼을 누르면 아래의 코드가 호출된다.
```jsx
changeVote(oldVote, newVote); // 각 투표는 '추천', '반대', '' 이다.
```

```jsx
const changeVote = function(oldVote, newVote) {
    let score = getScore();
    
    if (newVote !== oldVote) {
        if (newVote === "Up") {
            score += (oldVote === "Down" ? 2 : 1);
        } else if (newVote === "Down") {
            score -= (oldVote === "Up" ? 2 : 1);
        } else if (newVote === "") {
            score += (oldVote === "up" ? -1 : 1);
        }
    }
    
    setScore(score);
};
```
위 코드는 짧지만 많은 일을 수행하며 상세한 내용을 포함하므로 눈으로 미세한 에러, 오타, 다른 버그가 숨어있는지 확인하기 어렵다.
또한 한 번에 두 가지 일을 수행하는데,
1. `oldVote`와 `newVote`가 수치값으로 해석된다.
2. 점수가 변경된다.

각각의 작업을 분리하여 코드를 더 읽기 편하게 만들어보자.

```jsx
const getVoteValue = function(vote) {
    if (vote === "Up") {
        return 1;
    }
    if (vote === "Down") {
        return -1;
    }
    return 0;
};
```

```jsx
const changeVote = function(oldVote, newVote) {
    let score = getScore();
    
    score -= getVoteValue(oldVote); // 이전 값을 제거한다.
    score += getVoteValue(newVote); // 새 값을 더한다.
    
    setScore(score);
};
```
위와 같이 하나의 일만 하도록 분리하니 훨씬 보기 편해졌다.

작성한 코드가 읽기 어렵다면, 일단 수행하는 작업을 모두 나열해보자. 나열된 작업 중 일부는 별도의 함수나 클래스로 분리하고, 다른 작업은 원래 함수 내에서 별도의 논리적 '문단'으로 존재할 수 있다. 


### 코드 분량 줄이기
> 가장 읽기 쉬운 코는 아무것도 없는 코드다.

**그 기능을 구현하려고 애쓰지 마라 - 그럴 필요가 없다**
프로그래머는 대개 프로젝트에 정말로 필요한 기능이 얼마나 있는지 과대평가하는 경향이 있다. 또한, 어떤 기능을 구현하는 데 필요한 노력을 과소평가하는 경향도 있다. 
즉, 불필요한 기능을 구현하는 데에 많은 시간을 쏟거나 그런 코드들을 유지보수하는 데에 많은 시간이 소요될 수 있다는 것을 간과할 수 있다.

**코드베이스를 작게 유지하기**
프로젝트가 커지면 점점 어느 함수가 어느 함수를 호출하는지 기억하기 더 어려워지고, 버그를 잡는 데도 더 많은 노력이 필요하게 된다.
이러한 과정에 대처하기 위해 프로젝트가 성장하더라도 코드베이스를 최대한 작고 가볍게 유지하는 것이 중요하다.
- 일반적인 '유틸리티'를 많이 생성하여 중복된 코드를 제거하라
- 사용하지 않는 코드 혹은 필요 없는 기능을 제거하라
- 프로젝트가 서로 분절된 하위 프로젝트로 구서오디게 하라
- 코드베이스의 '무게'를 항상 의식하여 가볍고 날렵하게 유지시켜라

**자기 주변에 있는 라이브러리에 친숙해져라**
프로그래머는 이미 존재하는 라이브러리로 자신의 문제를 풀 수 있는 상황이 많다는 것을 모르거나 라이브러리가 할 수 있는 일을 잊어버리기도 한다. 라이브러리가 할 수 있는 일을 알고 활용하는 것은 중요하다.
이를 위해 매일 15분씩 자신의 표준 라이브러리에 있는 모든 함수/모듈/형들의 이름을 읽는 것도 좋은 방법이다. 라이브러리를 모두 암기하라는 것이 아니라, 그 안에 무엇이 있는지 머리에 인덱싱해두라는 뜻이다.

- 라이브러리를 이용하면 좋은 이유
    흔히 인용되는 통계에 따르면 평균적인 수준의 소프트웨어 엔지니어는 출시 할 수 있는 수준의 코드를 하루 평균 10줄 정도 작성한다고 한다.
    완숙한 라이브러리 안에 있는 코드는 한 줄 한 줄 모두 상당한 분량의 설계, 디버깅, 재작성, 문서화, 최적화, 테스트를 거친 코드이다. 이러한 라이브러리를 사용하면 시간도 절약하고, 코드양이 줄어들 수 있다.


## PART 4 선택된 주제들
### 테스트와 가독성
> 이 장에서는 간결하고 효과적으로 테스트를 작성하는 방법을 보여준다.

**읽거나 유지보수하기 쉽게 테스트를 만들어라**
테스트 코드가 읽기 쉬워야 한다는 점은 테스트와 상관 없는 실제 코드와 마찬가지로 중요하다. 
다른 프로그래머는 종종 테스트 코드를 실제 코드가 어떻게 동작하며 어떻게 사용되어야 하는지에 관한 비공식적인 문서라고 생각한다. 따라서 테스트 코드가 읽기 쉬우면, 사용자는 실제 코드가 어떻게 동작하는지 그만큼 더 쉽게 이해할 수 있다.

만약 테스트 코드가 어렵다면 아래와 같은 문제가 발생한다.
1. 코드를 수정한는 일이 두려워진다. 
2. 새로운 코드를 작성하면 그에 따르는 새로운 테스트를 작성하지 않는다. 시간이 지나면서 더 낮은 비율의 코드가 테스트되며, 따라서 코드에 대한 확신이 줄어들 수밖에 없다.

**테스트를 더 읽기 쉽게 만들기**
일반적인 설계원리를 따르면 덜 중요한 세부 사항은 사용자가 볼 필요 없게 숨겨서 더 중요한 내용이 눈에 잘 띄게 해야 한다.
최소한의 구문을 만들고 목적에 맞는 `미니 랭귀지`를 구현한다.
문자열에 일정한 문법적 규칙을 도입해서 자신만의 최적화된 `미니 랭귀지`를 사용한다면 작은 공간에 많은 정보를 표현할 수 있다.

**읽기 편한 메시지 만들기**
```jsx
assert(output === expectedOutput)
```
이라고 한다면, 여기서 `expectedOutput` 이 의미하는게 무엇인지 알 수 없다. 마찬가지로 output 또한 알 수 없다.

**좋은 테스트 입력값의 선택**
테스트에 알맞은 입력값을 선택하는 기술도 있다.

좋은 입력값은 코드를 구석구석 철저하게 테스트한다. 그러면서도 간단해서 읽기도 쉬워야 한다.
필요한 작업을 수행하는 범위에서 가장 명확하고 간단한 테스트 값을 선택해야한다.
또한, 코드를 구석구석 테스트하기 위해서는 하나의 완벽한 입력을 사용하는 것보다는 작은 테스트를 여러 개 사용하는 방식이 더 쉽고 효과적이다.


**테스트 함수에 이름 붙이기** 
테스트 코드는 주로 함수로 이루어져 있다.
테스트 함수를 위해 좋은 일므을 정하는 건 귀찮을 뿐만 아니라 별로 중요하지 않게 보인다.
하지만 `Test1() {}` `Test2() {}` 와 같이 전혀 의미가 없는 이름을 사용하면 곤란하다.
대신 테스트를 상세하게 묘사할 수 있는 이름을 사용하는 게 좋다. 특히 테스트 코드를 읽는 사람이 다음과 같은 상황을 빠르게 파악할 수 있다면 큰 도움이 된다.
- 테스트되는 클래스 
- 테스트되는 함수
- 테스트되는 상황이나 버그

테스트 함수에 좋은 일므을 붙이는 가장 단순한 방법은 접두사를 이용하여 필요한 정보를 모두 하나로 붙이는 것이다. 


**테스트에 친숙한 개발**
어떤 코드는 다른 코드보다 테스트하기 더 쉽다.
태스트하기 좋은 코드는 잘 정의된 인터페이스를 가지고, 지나치게 많은 상태나 '설정'을 요구하지 않으며, 감추어진 데이터를 포함하지 않는다.

지금 작성하는 코드의 테스트 코드를 나중에 작성할 거라는 사실을 염두에 두면 재미있는 일이 벌어진다. 지금 작성하는 코드를 나중에 테스트하기 쉽도록 설계하게 되는것이다.
테스트에 친숙한 설계는 서로 다른 일을 수행하는 부분을 서로 분리된 별도의 부분으로 구상하는, 전체적으로 잘 조직된 코드를 자연스럽게 낳는다.

> **테스트 주도 개발(TDD)**
> 실제 코드를 작성하기 전에 우선 테스트 코드부터 작성하는 프로그래밍 스타일이다.

##### 테스트 하기 어려운 코드의 특징과 이것이 설계와 관련된 문제에 미치는 영향
|특징 | 테스트 문제 | 설계 문제 |
| -------- | -------- | -------- |
| 전역 변수를 사용한다     |  테스트할 때마다 모든 전역 변수를 초기화해야 한다. 그렇지 않으면 테스트가 서로의 결과에 영향을 줄 수 있다.    |  어느 함수가 부수적인 효과를 가지는지 판별하기 어렵다. 각각의 함수를 별도로 고려할 수 없다. 모든 게 제대로 작동하는지 알려면 프로그램 전체를 생각해야 한다.   |
| 코드가 많은 외부 컴포넌트를 사용한다 | 처음에 설정할 일이 너무 많아서 테스트를 작성하기 힘들다. 따라서 테스트를 작성하는 일이 즐겁지 않아 테스트 작성을 회피한다. | 이러한 외부 시스템 중에서 어느 하나가 제대로 작동하지 않으면 프로그램이 실패한다. 프로그램에 가한 수정이 어떤 효과를 낳을지 알기 어렵다. 클래스들을 리팩토링하기 어렵다. 시스템이 더 많은 실패 모드와 복구 경로를 가지게 된다.  |
| 코드가 비결정적인 행동을 가진다  |  테스트가 변덕스럽고 안정적이지 못하다. 가끔 실패하는 테스트가 그냥 무시된다.    |   프로그램이 경합 조건이나 재생하기 어려운 버그를 가지고 있을 확률이 높다. 프로그램의 논리를 따라가기가 어렵다. 현장에서 발생한 버그를 추적해서 수정하기가 매우 어렵다.   |


##### 설계가 가지는 좋은 특징
| 특징 | 테스트 장점 | 설계 장점 |
| -------- | -------- | -------- |
| 클래스들이 내부 상태를 거의 가지고 있지 않다.     | 메소드를 테스트하기 전에 설정할 일이 거의 없고 감추어져 있는 상태가 별로 없기 때문에 테스트 작성이 수월하다.     | 소수의 내부 상태를 가지는 클래스는 이해하기 더 간단하고 쉽다.     |
| 클래스/함수가 한 번에 하나의 일만 수행한다.     | 더 적은 테스트 코드가 요구된다.     | 더 작고 간단한 컴포넌트는 더 잘 모듈화되어있고, 시스템이 서로 더 멀리 떨어져 있다.     |
| 클래스가 다른 클래스에 의존하지 않고, 서로 상당히 떨어져 있다.     | 각 클래스가 독립적으로 테스트된다 (여러 클래스를 동시에 테스트할 때에 비해서 훨씬 쉽다)     | 시스템이 병렬적으로 개발될 수 있다. 클래스가 쉽게 수정될 수 있고, 혹은 시스템의 나머지 부분에 영향을 주지 않으면서 제거될 수도 있다.     |
| 함수들이 간단하고 잘 정의된 인터페이스를 가지고 있다.     | 테스트 대상이 잘 정의되어 있다. 간단한 인터페이스는 테스트를 위해서 더 적은 일을 요구한다.     | 프로그래머가 인터페이스를 쉽게 배울 수 있어 해당 인터페이스는 재사용될 가능성이 더 높다. |


**지나친 테스트**
도가 지나친 수준으로 테스트에 관심을 갖는 경우도 있다.
- 테스트를 가능하게 하려고 실제 코드의 가독성을 희생시킨다. 실제 코드 테스트를 가능하게 하는 것은 반드시 win-win 상황이 되어야 하지만 테스트를 가능하게 하려고 실제 코드에 지저분하 코드를 집어넣으면 뭔가 잘못된 것이다.
- 100% 코드 테스트에 집착하는 일, 코드의 90%를 테스트하는 노력이 종종 나머지 10%를 테스트하는 비용보다 적은 노력이 들기도 한다. 그 10%는 어쩌면 버그로 인한 비용이 별로 높지 않기 때문에 굳이 테스트할 필요가 없는 사용자 인터페이스나 이상한 에러 케이스를 포함하고 있을지도 모른다.
- 사실, 코드를 100% 테스트하는 일은 일어나지 않는다. 테스트되지 않은 버그가 있을 수도 있고, 테스트되지 않은 기능이 있을 수도 있으며, 요구사항이 달라졌따는 사실을 모르고 있을 수도 있기 때문이다.
- 버그가 야기하는 비용이 어느 정도인지에 따라서, 테스트 코드를 작성하는 시간이 의미를 갖는 부분이있고 그렇지 않은 부분도 있기 마련이다. 만약 웹사이트의 프로토타입을 만든다면, 테스트 코드 작성건은 전혀 의미가 없다.
- 테스트 코드로 실제 제품 개발이 차질을 빚게 되는 일. 우리는 단지 프로젝트의 일부분에 불과한 테스트가 프로젝트 전체를 지배하는 경우를 본 적이 있다. 테스트가 숭배되어야 하는 신의 자리를 차지하고, 프로그래머들은 자신의 시간이 다른 일에 쓰이는 것이 더 낫다는 사실을 망각한 채 자신을 위한 의식과 동작에 몰두한다. 


테스트 코드에서 가독성은 여전히 중요한 자리를 차지한다. 테스트가 읽기 편하면 이를 작성하기 쉬워지고, 따라서 사람들은 더 많은 테스트를 작성하게 된다.

테스트를 개선하기 위한 구체적인 항목은 다음과 같다.
1. 각 테스트의 최상위수준은 최대한 간결해야 한다. 이상적으로는 각 테스트의 입출력이 한 줄의 코드로 설명될 수 있어야 한다.
2. 테스트에 실패하면 버그를 추적해서 수정하는데 도움이 될 만한 에러 메시지를 출력해야 한다.
3. 코드의 구석구석을 철저하게 실행하는 가장 간단한 입력을 사용하라.
4. 무엇이 테스트되는지 분명하게 드러나도록 테스트 함수에 충분한 설명이 포함된 이름을 사용해라.
5. 무엇보다 테스트의 수정이나 추가가 쉬워야 한다.









